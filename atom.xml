<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[晓然以至道]]></title>
  <subtitle><![CDATA[坚持学习，勤于思考]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-21T17:04:54.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[晓冰]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 语言基础]]></title>
    <link href="http://yoursite.com/2016/01/21/js-pro-04-base/"/>
    <id>http://yoursite.com/2016/01/21/js-pro-04-base/</id>
    <published>2016-01-21T14:09:02.000Z</published>
    <updated>2016-01-21T17:04:54.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript 的语言基础是在 ES3 的版本上基本定型的，后来 ES5 做了少许修改。</p>
<h1 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h1><p>ES 的语法大量借鉴了 C 及类 C 语言，还是比较好掌握的。例如：</p>
<ul>
<li>区分大小写</li>
<li>注释的方式</li>
</ul>
<h2 id="u6807_u8BC6_u7B26"><a href="#u6807_u8BC6_u7B26" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是指变量、函数、参数的名字，有以下规则：</p>
<ul>
<li>第一个字符必须是字母、下划线_、$。</li>
<li>其他字符可以是字母、下划线_、$ 或数字。</li>
<li>不能使用关键字或保留字。</li>
</ul>
<p>注意：</p>
<ul>
<li>这里指的字母可以是 Unicode 字符。</li>
<li>按照惯例，ES 中的命名是采用小驼峰的命名方式。</li>
</ul>
<h2 id="u4E25_u683C_u6A21_u5F0F"><a href="#u4E25_u683C_u6A21_u5F0F" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES5 引入了严格模式，strict mode，严格模式是为 js 定义了一种不同的解析和执行模型。在严格模式下，ES3 中一些不确定的行为得到了处理，并对一些不安全的操作抛出了错误。 要在整个脚本中启动严格模式，可以在顶部添加一行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">"use strict"</span>;</span><br></pre></td></tr></table></figure>
<p>这样没有破坏 ES3 的语法，对于不支持严格模式的环境，这也是一个有效的表达式，不会出错也不会影响任何逻辑。</p>
<p>也可以在一个函数内部打开严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要特别注意，严格模式的开启或关闭，会让程序结果有很大的不同。</p>
<h2 id="u8BED_u53E5"><a href="#u8BED_u53E5" class="headerlink" title="语句"></a>语句</h2><p>虽然 ES 中的语句是以一个分号结尾的，这个分号是可以省略由解析器帮忙插入分号。但是建议在任何时候都不要省略它。因为：</p>
<ul>
<li>可以避免很多不必要的隐藏错误</li>
<li>可以方便后期对代码进行去空格、空行、换行符的压缩。</li>
<li>对性能也有帮助，解析器不用再花时间去推测在哪里插入分号。</li>
</ul>
<h1 id="u5173_u952E_u5B57_u548C_u4FDD_u7559_u5B57"><a href="#u5173_u952E_u5B57_u548C_u4FDD_u7559_u5B57" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>               <span class="keyword">do</span>              <span class="keyword">instanceof</span>          <span class="keyword">typeof</span></span><br><span class="line"><span class="keyword">case</span>                <span class="keyword">else</span>            <span class="keyword">new</span>                 <span class="keyword">var</span></span><br><span class="line"><span class="keyword">catch</span>               <span class="keyword">finally</span>         <span class="keyword">return</span>              <span class="keyword">void</span></span><br><span class="line"><span class="keyword">continue</span>            <span class="keyword">for</span>             <span class="keyword">switch</span>              <span class="keyword">while</span></span><br><span class="line"><span class="keyword">debugger</span>*           <span class="function"><span class="keyword">function</span>        <span class="title">this</span>                <span class="title">with</span></span><br><span class="line"><span class="title">default</span>             <span class="title">if</span>              <span class="title">throw</span>               <span class="title">delete</span></span><br><span class="line"><span class="title">in</span>                  <span class="title">try</span></span></span><br></pre></td></tr></table></figure>
<p>其中，打 * 号的是 ES5 新增的。</p>
<p>ES3 的全部保留字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract            enum            int                 short</span><br><span class="line">boolean             <span class="keyword">export</span>          interface           static</span><br><span class="line">byte                extends         long                <span class="keyword">super</span></span><br><span class="line">char                final           native              synchronized</span><br><span class="line"><span class="class"><span class="keyword">class</span>               <span class="title">float</span>           <span class="title">package</span>             <span class="title">throws</span></span><br><span class="line"><span class="title">const</span>               <span class="title">goto</span>            <span class="title">private</span>             <span class="title">transient</span></span><br><span class="line"><span class="title">debugger</span>            <span class="title">implements</span>      <span class="title">protected</span>           <span class="title">volatile</span></span><br><span class="line"><span class="title">double</span>              <span class="title">import</span>          <span class="title">public</span></span></span><br></pre></td></tr></table></figure>
<p>由于 ES5 多了一个严格模式，所以 ES5 的保留字分严格模式下和非严格模式下。 ES5 把在非严格模式下运行时的保留字缩减为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>               <span class="title">enum</span>            <span class="keyword">extends</span>             <span class="title">super</span></span><br><span class="line"><span class="title">const</span>               <span class="title">export</span>          <span class="title">import</span></span></span><br></pre></td></tr></table></figure>
<p>ES5 严格模式下比非严格模式增加了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implements          package         public</span><br><span class="line">interface           private         static</span><br><span class="line"><span class="keyword">let</span>*                protected       <span class="keyword">yield</span>*</span><br></pre></td></tr></table></figure>
<p>ES5 是在 ES3 的基础上多加了两个保留字：let 和 yield</p>
<p>关于关键字和保留字还有注意两点：</p>
<ul>
<li>ES5 对关键字和保留字的规则做了修改，可以允许用做属性名，但是开发中最好不要这样做。</li>
<li>ES5 还限制了使用 eval 和 arguments 在严格模式下不能用于命名标识符和对象属性。</li>
</ul>
<h1 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h1><ul>
<li>ES 中的变量是松散类型的，一个变量可以用来保存任何类型的值。</li>
<li>使用 var 关键字定义变量。</li>
<li>只定义，不初始化的变量值是 undefined。</li>
<li>var 定义的变量是所在范围内的局部变量。</li>
<li>省略 var 定义的变量是全局变量，哪怕是在函数中定义的。要尽量避免这中做法，因为在局部范围定义全局变量是很难维护的。</li>
<li>可以同时定义多个变量，用 var开头，用逗号隔开，可以跨多行。</li>
</ul>
<h1 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>简单类型<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
</li>
<li>复杂类型<ul>
<li>Object</li>
</ul>
</li>
</ul>
<p>ES 不支持任何创建自定义类型的机制，所有的值都只属于上面6中类型之一。 初一想才6种类型怎么能适用复杂的使用场景，但是别忘了 ES 是动态语言，用这6种类型就可以玩转了。</p>
<h2 id="typeof__u64CD_u4F5C_u7B26"><a href="#typeof__u64CD_u4F5C_u7B26" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>就是因为 js 是松散的类型，所以需要一种手段来检测变量的数据类型，typeof 就是这样一个操作符。 </p>
<blockquote>
<p>注意， typeof 是操作符，不是函数。 </p>
</blockquote>
<p>对一个值使用 typeof 操作符可能返回下面的其中一个字符串：</p>
<ul>
<li>‘undefined’</li>
<li>‘boolean’</li>
<li>‘string’</li>
<li>‘number’</li>
<li>‘object’</li>
<li>‘function’</li>
</ul>
<p>注意 undefined 代表没有定义的，下面两种情况都返回 undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> abc);          <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> abc;</span><br><span class="line">alert(<span class="keyword">typeof</span> abc);          <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 typeof null 返回的是 object</p>
</blockquote>
<h2 id="Undefined__u7C7B_u578B"><a href="#Undefined__u7C7B_u578B" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><p>Undefined 类型只有一个值： undefined。 在使用 var 声明变量但未对其初始化时，这个变量的值就是 undefined。 这个类型是 ES3 中引进的，用来比较/区分空对象指针和未经初始化的变量。主要用来做比较，而不是用来赋值的。</p>
<p>但是未初始化的变量和未定义的变量还是不一样的的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xxx</span><br><span class="line">alert(xxx);          <span class="comment">// undefined</span></span><br><span class="line">alert(yyy);          <span class="comment">// 报错：Uncaught ReferenceError: xxx is not defined</span></span><br><span class="line">xxx == yyy;          <span class="comment">// 报错：Uncaught ReferenceError: xxx is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yyy;</span><br><span class="line">alert(yyy);          <span class="comment">// undefined</span></span><br><span class="line">xxx == yyy;          <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是，有一个特殊，未经定义的变量是<strong>可以且只能</strong>用于 typeof 操作符（其他对未经定义的变量的操作都会报错），就像上面出现过的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> abc);          <span class="comment">// undefined，不会报错。</span></span><br><span class="line"><span class="keyword">var</span> abc;</span><br><span class="line">alert(<span class="keyword">typeof</span> abc);          <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="Null_u7C7B_u578B"><a href="#Null_u7C7B_u578B" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null 类型也只有一个值： null。从逻辑角度来看，null代表一个空对象指针，而这也正是用 typeof 操作符检测 null 时返回 ‘object’ 的原因。</p>
<p>如果定义的变量是准备用来保存对象，那么最好将该对象初始化为 null，而不是其他值。这样，只要检测 nll 值就可以知道这个变量是否已近保存了一个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 car 对象进行赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上 undefined 值是派生自 null 值的，因此 ES 规定对于它们的相等性测试要返回 true</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>);       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>虽然 null 和 undefined 有这样的关系，但是它们的用途完全不同：</p>
<ul>
<li>一般没有必要给变量显示赋值 undefined，因为被定义而没有别初始化的变量就是 undefined 。</li>
<li>如果要给一个准备保存对象的变量初始化就应该 赋值为 null。</li>
</ul>
<h2 id="Boolean__u7C7B_u578B"><a href="#Boolean__u7C7B_u578B" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p>虽然 Boolean 类型的字面值只有两个：true 和 false，但 ES 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为对应的 Boolean 值，可以调用转换函数 Boolean()。转换规则是：</p>
<ul>
<li>字符串，非空==true</li>
<li>数字，0 和 NaN 的数字 == false，其他的 == true</li>
<li>对象，null == false，其他的 == true</li>
<li>undefined == false</li>
</ul>
<h2 id="Number__u7C7B_u578B"><a href="#Number__u7C7B_u578B" class="headerlink" title="Number 类型"></a>Number 类型</h2><p>ES 中的 number 类型使用 IEEE754 格式来表示整数和浮点数。</p>
<p>不同的表示方法：</p>
<ul>
<li>十进制： var a = 23;</li>
<li>八进制： var b = 070; 以0（零）开头</li>
<li>十六进制： var c = 0xFF; 以 0x 开头。</li>
</ul>
<h3 id="u6D6E_u70B9_u6570_u503C"><a href="#u6D6E_u70B9_u6570_u503C" class="headerlink" title="浮点数值"></a>浮点数值</h3><p>由于保存浮点数需要的空间是整数的两倍，所以 ES 会不失时机的把浮点数转换为整数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1.</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">10.0</span>;</span><br></pre></td></tr></table></figure>
<p>对于很大或者很小的数，可以使用科学表示法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3.125e7</span>;           <span class="comment">// 31250000</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">3e-17</span>;             <span class="comment">// 0.00000000000000003</span></span><br></pre></td></tr></table></figure>
<p>虽然浮点数的最高精度是17位小数，标书的数的范围大大宽于整数，但是进行算术运算时其精度远远不如整数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0.2</span>;</span><br><span class="line">x + y == <span class="number">0.3</span>;          <span class="comment">// false， x + y 的结果是：0.30000000000000004</span></span><br></pre></td></tr></table></figure>
<p>但是，用 0.05 + 0.25 的结果又是精确的。</p>
<blockquote>
<p>只要是采用 IEEE754 格式表示的浮点数都有精度问题。</p>
</blockquote>
<h3 id="u6570_u503C_u8303_u56F4"><a href="#u6570_u503C_u8303_u56F4" class="headerlink" title="数值范围"></a>数值范围</h3><p>number 能表示最大值和最小值分别是：Number.MAX_VALUE &amp; Number.MIN_VALUE，如果某个计算的值超出了这个范围，就会返回 Infinity 或 -Infinity 。<br>这两个特殊的值都不能参与计算。 函数 isInfinite() 函数可以判断数值是否在 number 表示的范围内。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN 用来表示一个本来应该返回数值的操作数未返回数值的情况，这样就不会报错了。 例如 <code>&#39;sdsf&#39; / 0</code> 。而其他语言中，这样的变态操作就会报错了。</p>
<p>NaN 还有两个特点：</p>
<ul>
<li>任何 NaN 参与的操作都会返回 NaN。</li>
<li>NaN 和任何值都不相等。 <code>NaN != NaN</code></li>
</ul>
<p>ES 定义了 isNaN() 函数，这个函数会先尝试转换数值，不能被转换为数值的返回结果 true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);         <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">10</span>);          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'10'</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'ab'</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>);        <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>isNaN() 还可以针对 object ，会先调用 valueOf() 和 toString() 方法，看是否可以转换为数值。</p>
<h3 id="u6570_u503C_u8F6C_u6362"><a href="#u6570_u503C_u8F6C_u6362" class="headerlink" title="数值转换"></a>数值转换</h3><p>有 3 个数值转换函数：</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>parseFloat()</li>
</ul>
<p>Number() 函数的转化规则：</p>
<ul>
<li>Boolean，true-&gt; 1， false -&gt; 0</li>
<li>null -&gt; 0</li>
<li>undefined -&gt; NaN</li>
<li>string 则会尽可能的转换。</li>
<li>string 中如果是合法的十六进制数表示法，也可以转换成功。</li>
<li>空字符串转换为 0</li>
<li>其他不能转换的字符串，得到 NaN</li>
<li>对象，先检查 valueOf() 的值，用前面的方法看是否可以转换为数值，如果不能就调用 toString() 方法，看得到的值是否能用前面的方法转换得到数值。</li>
</ul>
<p>由于 Number() 函数的规则复杂而且有些case 不合理，因此在处理整数时更常用的是用 parseInt() 函数。parseInt() 的规制是：</p>
<ul>
<li>忽略字符串前面的空格，直到找到第一个非空字符。如果这第一个非空字符不是数值或负号，则返回 NaN，也就是说空字符串会转换为 NaN，而不是0。</li>
<li>然后找接着的第二个字符，一直找到不是数值的为止，把这些识别出来的数值一起转换为数值。</li>
<li>十六进制的数格式也能认。</li>
<li>ES3 中支持 八进制格式，但是 ES5中是不支持的。但是 ES5 中提供了另外一个 parseInt() 的函数，可以多带一个参数，制定进制格式。这时，第一个参数可以不带 0 或 0x 的前缀。</li>
</ul>
<p>parseFloat() 和 parseInt() 的规制差不多，除了：</p>
<ul>
<li>可识别的第一个有效字符加上了点。</li>
<li>只识别 十进制。</li>
</ul>
<h2 id="String__u7C7B_u578B"><a href="#String__u7C7B_u578B" class="headerlink" title="String 类型"></a>String 类型</h2><p>字符都是 16位的 Unicode。<br>ES中定义字符串，用单引号和双引号没有区别。<br>支持转义字符，特殊转义字符有：</p>
<ul>
<li>\’ 单引号</li>
<li>\” 双引号</li>
<li>\xnn  以十六进制代码 nn 表示的一个字符 </li>
<li>\xnnnn  以十六进制代码 nn 表示的一个Unicode字符</li>
</ul>
<p>在 ECMAScript 5 标准中，字符串还可以被当做只读数组操作，除了可以使用 charAt() 方法，还可以用中括号来访问单个字符。</p>
<h3 id="u5B57_u7B26_u7684_u4E0D_u53EF_u53D8_u6027"><a href="#u5B57_u7B26_u7684_u4E0D_u53EF_u53D8_u6027" class="headerlink" title="字符的不可变性"></a>字符的不可变性</h3><p>字符串一旦创建，它的值就不能改变。类似 replace() 或 toUpperCase() 等方法是返回新字符串，原字符串并没有发生改变。</p>
<h3 id="u8F6C_u6362_u5B57_u7B26_u4E32"><a href="#u8F6C_u6362_u5B57_u7B26_u4E32" class="headerlink" title="转换字符串"></a>转换字符串</h3><ul>
<li>方法1：除了 undefined 和 null，其他的类型都有 toString 方法，返回各自的字符串形式。同样，对于字符，toString 方法还可以带一个参数制定进制格式。</li>
<li>方法2：还有一个 String() 方法，如果被转值有 toString 方法就调用此方法，undefined 就返回 undefined； null 就返回 null。</li>
<li>方法3：一个变通的方法：把它和一个空字符串 ‘’ 相加。</li>
</ul>
<h2 id="Object__u7C7B_u578B"><a href="#Object__u7C7B_u578B" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>ES中的对象其实是一组数据和功能的组合。对象可以通过执行 new 操作符后跟要创建的对象类型的名字来创建。而为实例添加属性和方法，就可以创建自定义的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>如果构造函数没有参数，后面的括号都可以去掉，但是不推荐这样做。</p>
<p>在 ES 中，Object 类型是所有它的实例的基础，换句话说， Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object 的每个实例都具有如下的属性/方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数。构造函数。</li>
<li>hasOwnProperty：用于检查给定的属性在当前对象实例中是否存在。参数是一个字符串表示属性名。</li>
<li>isPrototypeOf：用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable：用于检查给定的属性是否能够使用 for-in 语句来枚举。</li>
<li>toLocaleString：返回对新的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString：返回对象的字符串表示。</li>
<li>valueOf：返回对新的字符串、数值、或布尔值表示。通常与 toString 的返回值相同。</li>
</ul>
<p>#操作符</p>
<p>分为一下几种操作符：</p>
<ol>
<li>一元操作符</li>
<li>位操作符</li>
<li>布尔操作符</li>
<li>乘性操作符</li>
<li>加性操作符</li>
<li>关系操作符</li>
<li>相等操作符</li>
<li>赋值操作符</li>
<li>条件操作符</li>
<li>逗号操作符</li>
</ol>
<p>其他的没什么特殊的，就相等操作符有点特殊，需要搞清楚：</p>
<ul>
<li>相等：先转换在比较</li>
<li>全等：仅比较不准换</li>
</ul>
<p>相等比较时，由于涉及到了数据类型的转换，所以变得有点复杂，规则是：</p>
<ul>
<li>如果一个操作数是布尔值，则 false -&gt; 0,  true -&gt; 1</li>
<li>如果一个操作数是字符串，另一个是数值，则比较前先把字符串转换为数值。</li>
<li>如果一个操作数是对象，另一个操作数不是，这调用对象的 valueOf 方法，用得到的基本类型值按照前面的规制转换。</li>
<li>null == undefined</li>
<li>NaN 和任何值都不相等，哪怕是和 NaN 自己相比较。</li>
<li>如果两个都是对象，就看他们是否指向同一个实例。</li>
</ul>
<blockquote>
<p>由于相等和不相等操作符存在类型转换的问题，推荐在做比较操作时尽可能的使用全等和不全等操作符。</p>
</blockquote>
<h1 id="u8BED_u53E5-1"><a href="#u8BED_u53E5-1" class="headerlink" title="语句"></a>语句</h1><p>其他语句都和 C 族的语句一样，比较特殊的有：</p>
<h2 id="for-in__u8BED_u53E5"><a href="#for-in__u8BED_u53E5" class="headerlink" title="for-in 语句"></a>for-in 语句</h2><p>for-in 语句是用来遍历对象属性的，被遍历的变量只是属性的名字，不是属性的值，要想访问属性的值要用如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    alert(<span class="built_in">window</span>[propName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch__u8BED_u53E5"><a href="#switch__u8BED_u53E5" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>js 中 switch 语句有自己的特色，<br>(1) switch 语句中可以使用任何类型，不像其他语言只能用数值。无论是字符串、还是对象都没有问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (“hello world”) &#123;</span><br><span class="line">    <span class="keyword">case</span> “hello” + “ world”:</span><br><span class="line">        alert(“Greeting was found.”);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> “goodbye”:</span><br><span class="line">        alert(“Closing was found.”);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        alert(“Unexpected message was found.”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 每个 case 的值不一定是常量，可以是变量，设置是表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        alert(“Less than <span class="number">0.</span>”);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">        alert(“Between <span class="number">0</span> and <span class="number">10.</span>”);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">        alert(“Between <span class="number">10</span> and <span class="number">20.</span>”);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        alert(“More than <span class="number">20.</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3) switch 语句在比较值时使用的是全等操作，因此不会发生类型转换。例如 ‘10’ 不等于 10。</p>
<h1 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h1><p>ES 中的函数不必指定是否返回值。 <code>return;</code> 语句后面什么都不跟的是返回 undefined 。</p>
<p>在定义时是两个参数，可调用时可以是任意个数的参数，参数的类型也可以是任何类型。因为传进函数的是一个数组，这个数组的名字叫做 arguments。因此可以通过 数组下标的方式可以访问到到所有的参数。</p>
<p>正是因为函数的参数个数和类型都是不定的，所以就没有函数签名，也就没有 java 或 C# 中的函数重载。</p>
<p>函数的参数都是值传递，没有引用传递。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript 的语言基础是在 ES3 的版本上基本定型的，后来 ES5 做了少许修改。</p>
<h1 id="u8BED_u6CD5"><a href="#u8BED_u6CD5" class="headerlink" title="语法"></a>语法</h1>]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 在 HTML 中的加载和执行]]></title>
    <link href="http://yoursite.com/2016/01/20/js-pro-03-js-in-html/"/>
    <id>http://yoursite.com/2016/01/20/js-pro-03-js-in-html/</id>
    <published>2016-01-20T03:14:32.000Z</published>
    <updated>2016-01-20T07:00:43.000Z</updated>
    <content type="html"><![CDATA[<p><code>&lt;script&gt;</code> 可以用两种方式加入到 HTML中，内嵌方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined"></span><br><span class="line">    ....</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从文件加载：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"js/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript__u811A_u672C_u6267_u884C_u7684_u963B_u585E_u6027"><a href="#JavaScript__u811A_u672C_u6267_u884C_u7684_u963B_u585E_u6027" class="headerlink" title="JavaScript 脚本执行的阻塞性"></a>JavaScript 脚本执行的阻塞性</h3><p>JavaScript在浏览器中被解析和执行时具有阻塞的特性，也就是说，当JavaScript代码执行时，页面的解析、渲染以及其他资源的下载都要停下来等待脚本执行完毕。阻塞是因为浏览器需要一个稳定的DOM结构，而JavaScript可能会修改DOM(改变DOM结构或修改某个DOM节点)，如果在JavaScript执行的同时还继续进行页面的解析，那么整个解析过程将变得难以控制，解析出错的可能也变得很大。</p>
<h3 id="u811A_u672C_u7684_u6267_u884C_u987A_u5E8F"><a href="#u811A_u672C_u7684_u6267_u884C_u987A_u5E8F" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h3><p>浏览器是按照从上到下的顺序解析页面，因此正常情况下，JavaScript脚本的执行顺序也是从上到下的，即页面上先出现的代码或先被引入的代码总是被先执行，即使是允许并行下载JavaScript文件，且位于DOM下方的脚本先加载完也是后执行。</p>
<p>这里说的是正常的情况，还有一些非常规的方法用的很少，不讨论。例如：通过document.write方法向页面写入<code>&lt;script&gt;</code>标签或代码。或者通过Ajax获取脚本内容，然后再创建<code>&lt;script&gt;</code>元素，并设置元素的text，再将元素添加进DOM中。</p>
<h3 id="defer__u7279_u6027"><a href="#defer__u7279_u6027" class="headerlink" title="defer 特性"></a>defer 特性</h3><p>正常情况下，我们引入的脚本会被立即下载和执行，而有了defer特性之后，脚本下载完毕后不会立即执行，而是等到页面解析完毕之后再执行。但是，defer的脚本依然是在DOMContentLoaded事件之前执行的，因此它还是会阻塞DOMContentLoaded中的脚本。而且，要注意的是内部脚本不支持defer。</p>
<p>一句话解释就是，立即下载，稍候执行。</p>
<p>上面说的是正常情况，但实际在不同的浏览器中，不能保证 defer 在 DOMContentLoaded 之前执行，也不能保证多个 defer 脚本的执行顺序，所以把 defer 脚本放在 DOM 的尾部(<code>&lt;/body&gt;</code>之前)是最佳的做法，而且最好只包含一个 defer 的脚本。</p>
<h3 id="async__u7279_u6027"><a href="#async__u7279_u6027" class="headerlink" title="async 特性"></a>async 特性</h3><p><em>async特性是HTML5中引入的特性</em>，这里的异步，指的其实是异步加载而不是异步执行，也就是说，浏览器遇到一个async的<code>&lt;script&gt;</code>标签时，会异步的去加载，一旦加载完毕就会执行代码，而执行的过程肯定还是同步的，也就是阻塞的。这样来看的话，async脚本的执行时机是无法确定的，因为脚本何时加载完毕也是不确定的，而且执行的顺序也是不确定的，因此使用async的脚本应该是不依赖于任何代码的脚本(比如第三方统计代码或广告代码)，否则就会导致执行出错。</p>
<p>如果<code>&lt;script&gt;</code>元素同时定义了defer和async特性，则按async来处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>&lt;script&gt;</code> 可以用两种方式加入到 HTML中，内嵌方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="lin]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当我们谈 JavaScript 时，我们在谈论什么？]]></title>
    <link href="http://yoursite.com/2016/01/20/js-pro-02-concept/"/>
    <id>http://yoursite.com/2016/01/20/js-pro-02-concept/</id>
    <published>2016-01-19T16:21:38.000Z</published>
    <updated>2016-01-19T16:46:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u548C_ECMAScript__u7684_u5173_u7CFB"><a href="#JavaScript__u548C_ECMAScript__u7684_u5173_u7CFB" class="headerlink" title="JavaScript 和 ECMAScript 的关系"></a>JavaScript 和 ECMAScript 的关系</h2><p>在 JavaScript 的历史 一文中，描述了从 JavaScript 到 ECMAScript 的发展历史。1996年，Netscape 把自己的 JavaScript 1.1 交给 ECMA，就有了 ECMAScript 1.0。 ECMA 没有继续用 JavaScript 的名字是为了避开 Sun 和 Netscape 分别拥有的 Java 和 JavaScript 的商标。保证这门语言的开放性和中立性。</p>
<p>虽然 JavaScript 和 ECMAScript 通常都被人们用来表达相同的含义，但 JavaScript 的含义却比 ECMAScript 中规定的要多得多。 一个完整的 JavaScrit 实现应该由以下三个不同的部分组成：</p>
<ul>
<li>核心，即 ECMAScript</li>
<li>文档对象模型，即 DOM</li>
<li>浏览器对象模型，即 BOM</li>
</ul>
<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>由 ECMA-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262 定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。包括：</p>
<ul>
<li>语法</li>
<li>数据类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象</li>
</ul>
<p>我们常见的 Web 浏览器只是 ECMAScript 实现的宿主环境之一。另外的 ES 实现还有：JScript，ActionScript，Node.js。宿主环境不仅提供基本的 ECMAScript 的实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。如 DOM 就是利用 ECMAScript 的核心类型和语法提供更多具体的功能，实现了对文档对象的操作。</p>
<p>在日常场合，JavaScript 和 ECMAScript 这两个词是可以互换的。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（DOM），是针对 XML 但经过扩展用于 HTML 的 API。 DOM 把整个页面映射为一个多层节点结构。HTML 页面上的每个组成部分都是某种类型的节点。</p>
<p>在 DOM 出现之前，开发人员要想在页面加载完后修改页面的内容是借助 DHTML。 然而，DHTML 在给 Web 技术发展带来巨大进步的同时，也带来了巨大的问题。由于 Netscape 和 微软在 DHTML 的分歧，就出现了同样的代码在不同的浏览器上互不兼容的问题。此时，负责制定 Web 通行标准的 W3C 开始着手规划 DOM。</p>
<p>1998年10月，DOM1（DOM Level 1）成为了 W3C 的推荐标准。DOM1 由两个模块组成：</p>
<ul>
<li>DOM Core，规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的操作。</li>
<li>DOM HTML，在 DOM Core 的基础上扩展，添加针对 HTML 的对象和方法。</li>
</ul>
<p>如果说 DOM1 的目标主要是映射文档的结构，那么 DOM2 的目标就要宽泛的多。DOM2 在 DOM1 的基础上扩充了（DHTML 一直都支持的） 鼠标和用户界面事件、范围、遍历等细分模块。包括：</p>
<ul>
<li>DOM 视图，定义了跟踪不同文档（例如，应用 css 之前和之后的文档）视图的接口。</li>
<li>DOM 事件，定义了事件和事件处理的接口。</li>
<li>DOM 样式，定义了基于 CSS 为元素应用样式的接口。</li>
<li>DOM 遍历和范围，定义了遍历和操作文档树的接口。</li>
</ul>
<p>DOM3 则进一步扩展 DOM，引入了以统一方式加载和保存文档的方式、验证模块。DOM3 还对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base。</p>
<blockquote>
<p>有的地方可能会看到 DOM0。事实上， DOM 0 Level 是不存在的。 DOM0 指的是 IE4 和 Netscape Navigator 4.0 最初支持的 DHTML。</p>
</blockquote>
<p>各个浏览器对 DOM 支持到的级别不同。但是目前主流浏览器的最新版本都支持到 DOM3。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM 就是 Browser Object Model，支持访问和操作浏览器窗口。可以用来控制浏览器显示的页面以外的部分。 而 BOM 真正与众不同的地方（也是经常导致问题的地方），还是它作为 js 实现的一部分但却没有相关标准。这个问题在 HTML5 中得到了解决。 BOM 支持的操作包括：</p>
<ul>
<li>弹出新浏览器窗口</li>
<li>移动，缩放和关闭浏览器</li>
<li>提供浏览器详细信息的  navigator 对象</li>
<li>提供显示器信息的 screen 对象</li>
<li>对 cookie 的操作</li>
<li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li>
</ul>
<p>对于已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些共同特性，但还是有一些特性会存在因浏览器之间的差异。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u548C_ECMAScript__u7684_u5173_u7CFB"><a href="#JavaScript__u548C_ECMAScript__u7684_u5173_u7CFB" class="headerlink" title]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 的历史]]></title>
    <link href="http://yoursite.com/2016/01/19/js-pro-01-history/"/>
    <id>http://yoursite.com/2016/01/19/js-pro-01-history/</id>
    <published>2016-01-19T15:29:23.000Z</published>
    <updated>2016-01-19T16:43:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript__u7684_u8BDE_u751F"><a href="#JavaScript__u7684_u8BDE_u751F" class="headerlink" title="JavaScript 的诞生"></a>JavaScript 的诞生</h2><p>JavaScript 诞生于1995年。没错，和 Java 是同一年诞生的。可尽管 js 的语法和编程风格与 java 都很相似，但 js 和 java 却有本身本质上的区别，甚至它们两没有太大关系。 js 是一种非常松散的面向对象语言，属于动态语言。</p>
<p>在 js 出现之前，web表单的验证都是在服务器端做的，当时互联网还是运行在“猫”上的，速度只有可怜的 28.8 Kbit/s。试想如果提交一个表单要10秒钟后才提示某个字段是必填的，我疯掉的。</p>
<p>当时，走在IT技术革新最前沿的是 Netscape 公司，就决定要开发一种运行在客户端的语言，用来处理这种简单的客户端验证。于是他们开始为将在 1995年2月发布的 Netscape Navigator2 开发一种叫做 LiveScript 的脚本语言。该语言将同时在服务器中运行叫做 LiveWare。后来由于是和 Sun 公司一起组建开发联盟一起来开发这个新技术，同时为了接当时媒体热炒的Java，在这时发布时改名为 JavaScript。</p>
<h2 id="JavaScript__u7684_u53D1_u5C55"><a href="#JavaScript__u7684_u53D1_u5C55" class="headerlink" title="JavaScript 的发展"></a>JavaScript 的发展</h2><ul>
<li>由于 js 1.0 获得了巨大的成功，Netscape Navigator 3 中又发布了 js 1.1</li>
<li>1996年8月，微软为其 IE3 中加入了名为 JScript 的js实现。随着微软的掺和，导致了js版本的分裂，让 js 的标准化提上了日程。</li>
<li>1997年，以 Netscape JavaScript 1.1 为蓝本的建议被提交到欧洲计算机执照协会（ECMA）。他们经过数月的努力完成了 ECMA-263，定义了一种名为 ECMAScript 的新脚本语言标准。 ECMAScript 1.0</li>
<li>1998年，ISO 也采用了 ECMAScript 作为标准 ISO/IEC-16262</li>
<li>1998年6月，发布了 ECMAScript 2.0 ，只是为了和 ISO/IEC-16262 保持严格一直做了一些编辑加工，没有做任何新增、修改或删除。</li>
<li>1999年12月，发布了 ECMAScript 3.0 ，3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。修改的内容涉及字符串处理、错误定义和数值输出，这一版本还新增了对正则表达式、新控制语句、try-catch异常处理的支持。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。</li>
<li>2000年，ECMAScript 4.0开始酝酿，2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是由于这个版本太激进了，对ES3做了彻底升级，各方对于是否通过这个标准，发生了严重分歧。导致这个版本最后没有通过，但是它的大部分内容被ES6继承了。（因此，ES6制定的起点其实是2000年。）</li>
<li>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。</li>
<li>2009年12月，ECMAScript 5.0 版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next 继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。</li>
<li>2011年6月，ECMAscript 5.1 版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。</li>
</ul>
<h2 id="ECMAScript_6__u548C_ECMAScript_2015"><a href="#ECMAScript_6__u548C_ECMAScript_2015" class="headerlink" title="ECMAScript 6 和 ECMAScript 2015"></a>ECMAScript 6 和 ECMAScript 2015</h2><ul>
<li>2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。</li>
<li>2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。</li>
<li>2015年6月，ECMAScript 6 正式通过，成为国际标准。从2000年算起，这时已经过去了15年。</li>
</ul>
<p>ECMA 计划，以后每年发布一次标准，使用年份作为标准的版本。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015，下一年应该会发布小幅修订的ES2016。</p>
<p>这个历史剧情还蛮狗血的，有么有。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="JavaScript__u7684_u8BDE_u751F"><a href="#JavaScript__u7684_u8BDE_u751F" class="headerlink" title="JavaScript 的诞生"></a>JavaScript 的诞生]]>
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 切换版本工具 - nvm]]></title>
    <link href="http://yoursite.com/2016/01/18/nodejs-switch-version/"/>
    <id>http://yoursite.com/2016/01/18/nodejs-switch-version/</id>
    <published>2016-01-18T03:45:23.000Z</published>
    <updated>2016-01-19T02:19:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4E00_u4E2A_Node-js__u7248_u672C_u4E0D_u591F_u7528_uFF1F"><a href="#u4E00_u4E2A_Node-js__u7248_u672C_u4E0D_u591F_u7528_uFF1F" class="headerlink" title="一个 Node.js 版本不够用？"></a>一个 Node.js 版本不够用？</h3><p>本来周末想要学习一下 React Native，做一个 helloworld 出来体验一下。第一步就被阻，初始化命令<code>react-native init helloworld</code>时报错，说我本机的 Node.js 版本是 0.12，版本太低了。</p>
<p>我之前装 node 0.12，就是被当时 node.js 和 io.js 的乱局吓到了，保守选了一个 io.js 之前那的稳定版本。如今已经基于 node 0.12 之上做了一些项目，不能随便升级版本。 虽然官方宣称 node 4.0+ 是支持之前的版本的，但是生产环境已经使用了 0.12 版本，就不要去冒险了。</p>
<p>怎么办，一个机器上能否有多个版本的node环境呢？我在网上找到了 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> , 它就是用来解决这个问题的。</p>
<h3 id="u5B89_u88C5_nvm"><a href="#u5B89_u88C5_nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h3><p>安装很简单，按照官网的介绍就一个脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class="number">30.1</span>/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>然后把终端重新打开就可以使用 nvm 命令了。</p>
<h3 id="u4F7F_u7528_nvm"><a href="#u4F7F_u7528_nvm" class="headerlink" title="使用 nvm"></a>使用 nvm</h3><p>例如，我要安装最新的 5.4.x 版本，就可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install <span class="number">5.4</span></span><br></pre></td></tr></table></figure>
<p>瞬间就安装完了，而且 nvm 默认会把刚安装好的 node.js 版本作为当前环境使用的版本。注意系统默认的版本还是之前安装的 0.12.4 ，只是当前运行环境的被盖了，执行下面的命令参看当前环境使用的 nodejs 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm current</span><br></pre></td></tr></table></figure>
<p>可以使用下面的命令，切换 node.js 环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use <span class="number">5.4</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>但是这个命令只会影响当前命令行，如果要想让系统每打开一个命令行就使用 5.4.1 版本，就在 切换到 5.4.1 后再执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default node</span><br></pre></td></tr></table></figure>
<p>切换到之前系统安装的 node，就用 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use system</span><br></pre></td></tr></table></figure>
<p>参看已经安装了的node环境可以用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure>
<p>其他用法参考 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm 的官网</a> 。</p>
<p>现在可以愉快的用新版本 nodejs 开发 React Native了。</p>
<p>忘了说了，上面的做法只适合 Mac 。 目前 nvm 对 Windows 好像支持不是很完美，可能以后会慢慢改进， Windows上的 nodejs 开发者请自救。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4E00_u4E2A_Node-js__u7248_u672C_u4E0D_u591F_u7528_uFF1F"><a href="#u4E00_u4E2A_Node-js__u7248_u672C_u4E0D_u591F_u7528_uFF1F" class=]]>
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="Utility" scheme="http://yoursite.com/tags/Utility/"/>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo 配置修改及安装扩展]]></title>
    <link href="http://yoursite.com/2016/01/13/hexo-config-ext/"/>
    <id>http://yoursite.com/2016/01/13/hexo-config-ext/</id>
    <published>2016-01-13T15:47:02.000Z</published>
    <updated>2016-01-14T02:26:15.000Z</updated>
    <content type="html"><![CDATA[<p>Hexo 其实整体来说还是能满足自己的需求的，简洁、大方、突出内容。但是还是有个别细节看上去不是很爽，比如说这个主题的文章字体太小又很粗，更何况每个人的审美又不同，架不住IT狗又是喜欢折腾的。此文特记录自己对 Hexo 和 NexT 主题做的配置修改、自定义样式、及扩展安装，以后 Hexo 或 NexT 升级后可以参考。</p>
<h1 id="u6B63_u6587_u5B57_u4F53_u7F8E_u5316"><a href="#u6B63_u6587_u5B57_u4F53_u7F8E_u5316" class="headerlink" title="正文字体美化"></a>正文字体美化</h1><p>参考了<a href="https://github.com/iissnan/hexo-theme-next/issues/111" target="_blank" rel="external">NexT主题的作者和使用者在GitHub上的交流</a> ，在博客的根目录下的 /source/css/_custom/custom.styl 文件中加入如下 css 代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">"TIBch"</span>, <span class="string">"Classic Grotesque W01"</span>, <span class="string">"Helvetica Neue"</span>, Arial, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"STHeiti"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, SimSun</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1.7</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#555</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">-webkit-font-smoothing</span>:<span class="value"> antialiased</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="u8BBE_u7F6E_u6807_u9898_u548C_u526F_u6807_u9898"><a href="#u8BBE_u7F6E_u6807_u9898_u548C_u526F_u6807_u9898" class="headerlink" title="设置标题和副标题"></a>设置标题和副标题</h1><p>修改博客根目录下的 _config.yml 文件中的 #site 节：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: <span class="xml"><span class="tag">&lt;<span class="title">博客标题</span>&gt;</span></span><br><span class="line">subtitle: <span class="tag">&lt;<span class="title">博客副标题</span>&gt;</span></span><br><span class="line">description: <span class="tag">&lt;<span class="title">博客简介</span>&gt;</span></span><br><span class="line">author: <span class="tag">&lt;<span class="title">博客主的昵称</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="u8BBE_u7F6E_u663E_u793A_u8BED_u8A00"><a href="#u8BBE_u7F6E_u663E_u793A_u8BED_u8A00" class="headerlink" title="设置显示语言"></a>设置显示语言</h1><p>修改博客根目录下的 _config.yml 文件中的 language 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<h1 id="u751F_u6210_u6458_u8981"><a href="#u751F_u6210_u6458_u8981" class="headerlink" title="生成摘要"></a>生成摘要</h1><p>修改主题目录下的 _config.yml 文件中的 auto_excerpt 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  length: <span class="number">150</span></span><br></pre></td></tr></table></figure>
<h1 id="u4EE3_u7801_u9AD8_u4EAE"><a href="#u4EE3_u7801_u9AD8_u4EAE" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>修改主题目录下的 _config.yml 文件中的 highlight_theme 属性，我比较喜欢 night eighties 配色方案</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: night eighties</span><br></pre></td></tr></table></figure>
<p>这是现实效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> math.abs(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6DFB_u52A0_RSS__u8BA2_u9605"><a href="#u6DFB_u52A0_RSS__u8BA2_u9605" class="headerlink" title="添加 RSS 订阅"></a>添加 RSS 订阅</h1><p>用到 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a> 插件，按照它的向导两步完成添加 RSS 订阅。 NexT 主题也很给力，它会自动在右侧边栏的<strong>站点概览</strong>中自动添加 RSS 按钮。</p>
<h1 id="u6DFB_u52A0_u6807_u7B7E_u9875_u548C_u5206_u7C7B_u9875_u9762"><a href="#u6DFB_u52A0_u6807_u7B7E_u9875_u548C_u5206_u7C7B_u9875_u9762" class="headerlink" title="添加标签页和分类页面"></a>添加标签页和分类页面</h1><p>参考 <a href="http://theme-next.iissnan.com/theme-settings.html#标签云页面" target="_blank" rel="external">NexT 主页的指南</a> 即可。 </p>
<p>另外在每篇文章的开头要加上标签和分类的属性才能被识别出来，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 配置修改及安装扩展</span><br><span class="line">tags: Hexo</span><br><span class="line">category: blog</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="u6DFB_u52A0_u6570_u5B66_u516C_u5F0F_u652F_u6301"><a href="#u6DFB_u52A0_u6570_u5B66_u516C_u5F0F_u652F_u6301" class="headerlink" title="添加数学公式支持"></a>添加数学公式支持</h1><p>编辑 主题配置文件，将 mathjax 设定为 true 即可，下面是一个数学公司的例子：</p>
<p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<p>我只能默默的感叹，NexT 主题真强！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hexo 其实整体来说还是能满足自己的需求的，简洁、大方、突出内容。但是还是有个别细节看上去不是很爽，比如说这个主题的文章字体太小又很粗，更何况每个人的审美又不同，架不住IT狗又是喜欢折腾的。此文特记录自己对 Hexo 和 NexT 主题做的配置修改、自定义样式、及扩展安装]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://yoursite.com/tags/NexT/"/>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo + GitHub Pages 搭建免费的静态博客]]></title>
    <link href="http://yoursite.com/2016/01/11/hexo-setup-base/"/>
    <id>http://yoursite.com/2016/01/11/hexo-setup-base/</id>
    <published>2016-01-10T16:31:46.000Z</published>
    <updated>2016-01-14T02:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>终于把博客搭好了。在这里把整个过程的大致步骤记录下来，供以后改造升级时参考。</p>
<h1 id="u9009_u578B"><a href="#u9009_u578B" class="headerlink" title="选型"></a>选型</h1><p>从开始决定要重新开始写博客时，就一直在考虑用什么来写博客。作为新时期有理想有节操的IT狗，肯定是要自己动手搭建才能体现出不同的逼格。另外一个要考虑的就是节约点成本。那第一个知道的就是 WordPress，是在比较传统的 LAMP 技术上搭建的，功能很丰富，有很多成熟漂亮的主题可以直接用。但是对于我来说，WP 太庞大，太过臃肿。另外一个目前比较流行的是用 Jekyll 在 GitHub 上写 Markdown 然后生成静态页面，还有它的表哥 Octopress，号称是想黑客一样写博客。其实是不错的选择，毕竟把静态页面放在 GitHub 上既稳定又不用花钱。不过由于 Jekyll 是基于 Ruby 技术栈的，我对 Ruby 不熟悉又暂时不打算学习 Ruby（听说性能有问题），所以迟迟没有动手去弄。前几天看到一个新的博客平台Ghost，它是基于 Node.js 基础上搭建的，听说是要成为 WP 的继任者，所以就下下来试了一下，确实是比较简单，很快就安装好了，和 Jekyll 一样，Ghost 也是用 Markdown 来写作的，而且 Ghost 还支持一边用 Markdown 写作，一边就可以看到生成文章的效果。但是有两点最后导致我暂时放弃了 Ghost，(1)就是 Ghost 刚出来，版本很不稳定，而且在社区中还没有太多的插件和主题供选择；(2)就是它需要我们自己部署到一个外网的服务器上才能访问。 后来我就在想有没有结合了 Jekyll 和 Ghost 的优势，即用 Node.js 技术做 Markdown 的生成静态页面部署到 GitHub 上去呢？到网上一找，最后找到了 Hexo。有种相见恨晚的感觉。Hexo 是由台湾的 <a href="https://github.com/hexojs/hexo" target="_blank" rel="external">tommy351</a> 开发的一款基于Node.js的静态博客框架。它支持用 支持GitHub Flavored Markdown 写作，因为基于 Node.js 运行，生成静态网页数据的速度极快，而且配合 Node.js 的生态，开发网页模板、定制主题、及开发插件都很方便。</p>
<h1 id="u73AF_u5883_u51C6_u5907"><a href="#u73AF_u5883_u51C6_u5907" class="headerlink" title="环境准备"></a>环境准备</h1><p>在安装使用 Hexo 之前，需要先安装一下软件：</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<p>安装的方式网上都有，这里就不赘述了。</p>
<h1 id="u5EFA_u7ACB_u81EA_u5DF1_u7684_GitHub__u9759_u6001_u7AD9"><a href="#u5EFA_u7ACB_u81EA_u5DF1_u7684_GitHub__u9759_u6001_u7AD9" class="headerlink" title="建立自己的 GitHub 静态站"></a>建立自己的 GitHub 静态站</h1><p>GitHub 真是一个好东西，不但为开源世界提供了优质的资源，还给我们这种屌丝提供了免费的、稳定的静态站点服务。</p>
<p>登录 GitHub，创建一个新的仓库，仓库的名字必须为你的 GitHub 的账户名开头，加上 github.io 为后缀，我的静态站仓库就是：richardzhaoxb.github.io</p>
<h1 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h1><p>如果前面 Node.js 和 Git 都安装好了，安装 Hexo 就是超级简单，比 Jekyll 的简单多了。执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h1><p>初始化就是生成一个 blog 的实例，还是很简单，执行下面的命名，指定要生成的目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>
<p>你可以在自己的机器上生成多个不同的实例，用于开发插件、测试主题、或者只为备份，随你。只要每次别进错目录就好。</p>
<h1 id="u5199_u6587_u7AE0"><a href="#u5199_u6587_u7AE0" class="headerlink" title="写文章"></a>写文章</h1><p>还是很简单，一个命令，指定要生成的文章的名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;post-name&gt;</span><br></pre></td></tr></table></figure>
<p>这个命令其实是在博客的根目录的 <strong>/source/_posts/</strong> 子目录下，生成了 post-name.md 的文件。如果知道了这一点，其实也可以复制<strong>_posts</strong>目录下的其他md文件来创建新文章。</p>
<p>接下来，就可以用 Markdown 在新生成的文件中写博客了。我用的是 Sublime Text，还装了一个叫做 MarkdownEditing 的插件，写起来很爽。</p>
<h1 id="u672C_u5730_u9884_u89C8"><a href="#u672C_u5730_u9884_u89C8" class="headerlink" title="本地预览"></a>本地预览</h1><p>执行以下命令，就可以启动 Node.js 本地服务，进行文章的预览调试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>默认的调试地址是：<a href="http://localhost:4000，也可以用" target="_blank" rel="external">http://localhost:4000，也可以用</a> -p 的命令参数指定端口号。</p>
<h1 id="u751F_u6210_u9759_u6001_u9875_u9762"><a href="#u751F_u6210_u9759_u6001_u9875_u9762" class="headerlink" title="生成静态页面"></a>生成静态页面</h1><p>如果本地调试好了，准备发布到 GitHub 上去，就必须先生成静态页面。在博客的根目录下，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<h1 id="u53D1_u5E03_u5230_GitHub"><a href="#u53D1_u5E03_u5230_GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h1><p>先到站点配置文件中，修改git库信息</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">  <span class="symbol">type:</span> git</span><br><span class="line">  <span class="symbol">repo:</span> git<span class="variable">@github</span>.<span class="symbol">com:</span>richardzhaoxb/richardzhaoxb.github.io.git</span><br></pre></td></tr></table></figure>
<p>然后安装 Hexo 在 git 上部署的插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>最后就可以执行命令发布了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>Hexo 还支持发布到不同的 静态 Pages 平台：Heroku、Rsync、OpenShift， 做法和上面类似，在不同的地方修改参数即可，具体参考<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">官网的说明</a> 。</p>
<h1 id="u4E3B_u9898"><a href="#u4E3B_u9898" class="headerlink" title="主题"></a>主题</h1><p>在 Hexo 官网上的主题推荐中，看中了 NeXT 主题。这个 Theme 简洁，突出内容，而且 NeXT 主题还有一个专门的 <a href="http://theme-next.iissnan.com/" target="_blank" rel="external">主页</a> 来介绍具体的使用。按照上面的一步一步做即可。感谢 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">iissnan</a> 提供这么优秀的主题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>终于把博客搭好了。在这里把整个过程的大致步骤记录下来，供以后改造升级时参考。</p>
<h1 id="u9009_u578B"><a href="#u9009_u578B" class="headerlink" title="选型"></a>选型</h1><p>从开始决定要]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://yoursite.com/tags/NexT/"/>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客 - 重新开始]]></title>
    <link href="http://yoursite.com/2016/01/06/blog-restart/"/>
    <id>http://yoursite.com/2016/01/06/blog-restart/</id>
    <published>2016-01-06T12:45:23.000Z</published>
    <updated>2016-01-14T01:50:33.000Z</updated>
    <content type="html"><![CDATA[<p>以前也曾经写过一段时间的博客，但是由于自己不善于表达自己的想法，没有养成随时分享的习惯，所以没有坚持下来。</p>
<p>虽然每天都很忙，但是大多数都是处理一些重复的，技术性的工作，慢慢觉得自己是一个没有思想的人。在思想上长期的偷懒，导致脑子里空空的，就会觉得自己很空虚。人可以活的很轻松，吃饭、睡觉、逛街、上网、打机、追剧，想一想这种生活真是安逸啊，但是每天只会吃饭睡觉不会思考没有观点的人，那和行尸走肉又有何不同。不是吗？</p>
<p>我不想继续做这样的人。</p>
<p>借助 GitHub Pages 这么方便、免费、自由的博客平台，我希望能重新开始写博客，并坚持下去。至少每个星期要写一篇博客。内容主要围绕工作学习相关的主题。身处软件行业，新语言，新技术，新浪潮，层出不穷，络绎不绝，需要不断学习、实践、思考、总结、分享，一开始就可以把自己的学到的东西、遇到的问题、解决的过程记录下来。可能我现在写的内容是如此的苍白、乏味，但是我相信只要坚持下去，多写、多琢磨，几年后的自己再看到这个博客的开篇时，不会感到害羞或唏嘘不已，而是感到的是欣慰、可爱和成就感。</p>
<p>最近看了《如何变得有思想》一书，用里面的一句话来督促自己：</p>
<blockquote class="blockquote-center">人不是生来就有思想的。思想是通过勤奋的学习和思考得来的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;- 阮一峰</blockquote>

<p>加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以前也曾经写过一段时间的博客，但是由于自己不善于表达自己的想法，没有养成随时分享的习惯，所以没有坚持下来。</p>
<p>虽然每天都很忙，但是大多数都是处理一些重复的，技术性的工作，慢慢觉得自己是一个没有思想的人。在思想上长期的偷懒，导致脑子里空空的，就会觉得自己很空虚。人]]>
    </summary>
    
      <category term="Timeline" scheme="http://yoursite.com/tags/Timeline/"/>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
